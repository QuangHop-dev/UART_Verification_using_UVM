Coverage Report by file with details

=================================================================================
=== File: A:/UART-VIP/FIFO_Contr.sv
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                        14        13         1    92.85%

================================Branch Details================================

Branch Coverage for file A:/UART-VIP/FIFO_Contr.sv --

------------------------------------IF Branch------------------------------------
    62                                      2646     Count coming in to IF
    62              1                          4             if (Reset) begin
    68              1                       2642             else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------CASE Branch------------------------------------
    98                                      3966     Count coming in to CASE
    103             1                       1320                 Read: begin
    116             1                       1320                 Write: begin
    130             1                    ***0***                 Read_and_Write: begin
    138             1                       1326                 default: begin
Branch totals: 3 hits of 4 branches = 75.00%

------------------------------------IF Branch------------------------------------
    104                                     1320     Count coming in to IF
    104             1                        784                     if (!empty_logic) begin
                                             536     All False Count
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    108                                      784     Count coming in to IF
    108             1                        540                         if (rd_ptr_succ == wr_ptr_logic)
                                             244     All False Count
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    117                                     1320     Count coming in to IF
    117             1                       1316                     if (!full_logic) begin
                                               4     All False Count
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    121                                     1316     Count coming in to IF
    121             1                          8                         if (wr_ptr_succ == rd_ptr_logic)
                                            1308     All False Count
Branch totals: 2 hits of 2 branches = 100.00%


Condition Coverage:
    Enabled Coverage              Bins   Covered    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Conditions                       2         2         0   100.00%

================================Condition Details================================

Condition Coverage for file A:/UART-VIP/FIFO_Contr.sv --

----------------Focused Condition View-------------------
Line       108 Item    1  (rd_ptr_succ == wr_ptr_logic)
Condition totals: 1 of 1 input term covered = 100.00%

----------------Focused Condition View-------------------
Line       121 Item    1  (wr_ptr_succ == rd_ptr_logic)
Condition totals: 1 of 1 input term covered = 100.00%


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      24        22         2    91.66%

================================Statement Details================================

Statement Coverage for file A:/UART-VIP/FIFO_Contr.sv --

    1                                                `timescale 1ns / 1ps
    2                                                /*=========================================================
    3                                                 * Module: FIFO_Contr
    4                                                 * Description:
    5                                                 *   FIFO control unit
    6                                                 *   - Manages read/write pointers
    7                                                 *   - Generates full and empty flags
    8                                                 *   - Supports read, write, and simultaneous read/write
    9                                                 *
    10                                                * Parameters:
    11                                                *   addr_width        : Address width (FIFO depth = 2^addr_width)
    12                                                *   Read              : Read operation encoding
    13                                                *   Write             : Write operation encoding
    14                                                *   Read_and_Write    : Simultaneous read & write encoding
    15                                                *=========================================================*/
    16                                               module FIFO_Contr #(
    17                                                   parameter addr_width       = 5,
    18                                                   parameter Read             = 2'b01,
    19                                                   parameter Write            = 2'b10,
    20                                                   parameter Read_and_Write   = 2'b11
    21                                               )(
    22                                                   /*-------------------------
    23                                                    * Clock & Reset
    24                                                    *-------------------------*/
    25                                                   input  logic                    clk,
    26                                                   input  logic                    Reset,
    27                                               
    28                                                   /*-------------------------
    29                                                    * Control inputs
    30                                                    *-------------------------*/
    31                                                   input  logic                    wr,
    32                                                   input  logic                    rd,
    33                                               
    34                                                   /*-------------------------
    35                                                    * Status outputs
    36                                                    *-------------------------*/
    37                                                   output logic                    full,
    38                                                   output logic                    empty,
    39                                               
    40                                                   /*-------------------------
    41                                                    * Address outputs
    42                                                    *-------------------------*/
    43                                                   output logic [addr_width-1:0]    w_addr,
    44                                                   output logic [addr_width-1:0]    r_addr
    45                                               );
    46                                               
    47                                                   /*=====================================================
    48                                                    * Internal state registers
    49                                                    *=====================================================*/
    50                                                   logic full_logic,  full_next;
    51                                                   logic empty_logic, empty_next;
    52                                               
    53                                                   logic [addr_width-1:0] wr_ptr_logic, wr_ptr_next, wr_ptr_succ;
    54                                                   logic [addr_width-1:0] rd_ptr_logic, rd_ptr_next, rd_ptr_succ;
    55                                               
    56                                                   /*=====================================================
    57                                                    * Sequential logic
    58                                                    * - State update on clock edge
    59                                                    * - Asynchronous reset
    60                                                    *=====================================================*/
    61              1                       2646         always_ff @(posedge clk or posedge Reset) begin
    62                                                       if (Reset) begin
    63              1                          4                 full_logic   <= 1'b0;
    64              1                          4                 empty_logic  <= 1'b1;
    65              1                          4                 wr_ptr_logic <= '0;
    66              1                          4                 rd_ptr_logic <= '0;
    67                                                       end
    68                                                       else begin
    69              1                       2642                 full_logic   <= full_next;
    70              1                       2642                 empty_logic  <= empty_next;
    71              1                       2642                 wr_ptr_logic <= wr_ptr_next;
    72              1                       2642                 rd_ptr_logic <= rd_ptr_next;
    73                                                       end
    74                                                   end
    75                                               
    76                                                   /*=====================================================
    77                                                    * Combinational logic
    78                                                    * - Next-state logic
    79                                                    *=====================================================*/
    80              1                       3966         always_comb begin
    81                                                       /*-------------------------
    82                                                        * Default assignments
    83                                                        *-------------------------*/
    84              1                       3966             full_next   = full_logic;
    85              1                       3966             empty_next  = empty_logic;
    86              1                       3966             wr_ptr_next = wr_ptr_logic;
    87              1                       3966             rd_ptr_next = rd_ptr_logic;
    88                                               
    89                                                       /*-------------------------
    90                                                        * Successive pointer values
    91                                                        *-------------------------*/
    92              1                       3966             wr_ptr_succ = wr_ptr_logic + 1'b1;
    93              1                       3966             rd_ptr_succ = rd_ptr_logic + 1'b1;
    94                                               
    95                                                       /*-------------------------
    96                                                        * Operation decoding
    97                                                        *-------------------------*/
    98                                                       unique case ({wr, rd})
    99                                               
    100                                                          /*---------------------
    101                                                           * Read operation
    102                                                           *---------------------*/
    103                                                          Read: begin
    104                                                              if (!empty_logic) begin
    105             1                        784                         rd_ptr_next = rd_ptr_succ;
    106             1                        784                         full_next   = 1'b0;
    107                                              
    108                                                                  if (rd_ptr_succ == wr_ptr_logic)
    109             1                        540                             empty_next = 1'b1;
    110                                                              end
    111                                                          end
    112                                              
    113                                                          /*---------------------
    114                                                           * Write operation
    115                                                           *---------------------*/
    116                                                          Write: begin
    117                                                              if (!full_logic) begin
    118             1                       1316                         wr_ptr_next = wr_ptr_succ;
    119             1                       1316                         empty_next  = 1'b0;
    120                                              
    121                                                                  if (wr_ptr_succ == rd_ptr_logic)
    122             1                          8                             full_next = 1'b1;
    123                                                              end
    124                                                          end
    125                                              
    126                                                          /*---------------------
    127                                                           * Simultaneous
    128                                                           * Read & Write
    129                                                           *---------------------*/
    130                                                          Read_and_Write: begin
    131             1                    ***0***                     wr_ptr_next = wr_ptr_succ;
    132             1                    ***0***                     rd_ptr_next = rd_ptr_succ;
    133                                                          end
    134                                              
    135                                                          /*---------------------
    136                                                           * No operation
    137                                                           *---------------------*/
    138                                                          default: begin
    139                                                              /* no-op */
    140                                                          end
    141                                              
    142                                                      endcase
    143                                                  end
    144                                              
    145                                                  /*=====================================================
    146                                                   * Output assignments
    147                                                   *=====================================================*/
    148                                                  assign full   = full_logic;
    149                                                  assign empty  = empty_logic;
    150                                                  assign w_addr = wr_ptr_logic;
    151                                                  assign r_addr = rd_ptr_logic;
    152                                              
    153                                              endmodule

Toggle Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Toggles                        104        99         5    95.19%

================================Toggle Details================================

Toggle Coverage for File A:/UART-VIP/FIFO_Contr.sv --

       Line                                   Node      1H->0L      0L->1H       0L->Z       Z->0L       1H->Z       Z->H1     ExtMode  "Coverage"
--------------------------------------------------------------------------------------------------------------------------------------------------
         26                                  Reset           2           0           0           0           0           0           3       16.66 

========
(n*) - Number was not used in coverage calculations performed by extended toggle algorithms.

Extended Toggle Coverage Calculation Criteria:
-----------------------------------------------
	ExtMode 1: 0L->1H & 1H->0L & any one 'Z' transition (to/from 'Z').
	ExtMode 2: 0L->1H & 1H->0L & one transition to 'Z' & one transition from 'Z'.
	ExtMode 3: 0L->1H & 1H->0L & all 'Z' transitions.
========

Total Node Count     =         50 
Toggled Node Count   =         49 
Untoggled Node Count =          1 

Toggle Coverage      =      95.19% (99 of 104 bins)

=================================================================================
=== File: A:/UART-VIP/UART_TOP.sv
=================================================================================
Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      13        13         0   100.00%

================================Statement Details================================

Statement Coverage for file A:/UART-VIP/UART_TOP.sv --

    1                                                `timescale 1ns / 1ns
    2                                                
    3                                                import uvm_pkg::*;
    4                                                import UART_pkg::*;
    5                                                
    6                                                `include "UART_interface.sv"
    7                                                
    8                                                module UART_TOP;
    9                                                
    10                                                   parameter Data_bits        = 9;
    11                                                   parameter Sp_ticks         = 16;
    12                                                   parameter St_ticks         = 8;
    13                                                   parameter Dt_ticks         = 16;
    14                                                   parameter addr_width       = 5;
    15                                                   parameter divsr_width      = 10;
    16                                                   parameter Read             = 2'b01;
    17                                                   parameter Write            = 2'b10;
    18                                                   parameter Read_and_Write   = 2'b11;
    19                                               
    20                                                   // 1 = loopback (tx->rx), 0 = rx comes from TB
    21                                                   parameter bit LOOPBACK = 1'b1;
    22                                               
    23                                                   logic CLK;
    24                                               
    25                                                   UART_interface intf (.CLK(CLK));
    26                                               
    27                                                   logic uart_rx_line;
    28              1                       2094         always_comb
    29              1                       2094             uart_rx_line = (LOOPBACK) ? intf.tx : intf.rx;
    30                                               
    31                                                   UART #(
    32                                                       .Data_bits       (Data_bits),
    33                                                       .Sp_ticks        (Sp_ticks),
    34                                                       .St_ticks        (St_ticks),
    35                                                       .Dt_ticks        (Dt_ticks),
    36                                                       .addr_width      (addr_width),
    37                                                       .divsr_width     (divsr_width),
    38                                                       .Read            (Read),
    39                                                       .Write           (Write),
    40                                                       .Read_and_Write  (Read_and_Write)
    41                                                   ) UART_As_Transmitter (
    42                                                       .clk            (CLK),
    43                                                       .Reset          (intf.Reset),
    44                                                       .rd_uart        (intf.rd_uart),
    45                                                       .wr_uart        (intf.wr_uart),
    46                                                       .rx             (uart_rx_line),
    47                                                       .w_data         (intf.w_data),
    48                                                       .divsr          (10'd54),
    49                                                       .rx_empty       (intf.rx_empty),
    50                                                       .tx_full        (intf.tx_full),
    51                                                       .tx             (intf.tx),
    52                                                       .r_data         (intf.r_data),
    53                                                       .incorrect_send (intf.incorrect_send),
    54                                                       .tx_done        (intf.tx_done),
    55                                                       .rx_done        (intf.rx_done)
    56                                                   );
    57                                               
    58              1                    6098416         always #5 CLK = ~CLK;
    58              2                    6098415     
    59                                               
    60                                                   initial begin
    61              1                          1             CLK           = 1'b0;
    62              1                          1             intf.Reset    = 1'b1;
    63              1                          1             intf.rd_uart  = 1'b0;
    64              1                          1             intf.wr_uart  = 1'b0;
    65              1                          1             intf.rx       = 1'b1; // idle high
    66              1                          1             intf.w_data   = '0;
    67              1                          1             intf.divsr    = 10'd54;
    68                                               
    69              1                          1             uvm_config_db #(virtual UART_interface)::set(null, "*", "intf", intf);
    70              1                          1             run_test("test");
    71                                                   end
    72                                               
    73                                               endmodule

Toggle Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Toggles                          4         4         0   100.00%

================================Toggle Details================================

Toggle Coverage for File A:/UART-VIP/UART_TOP.sv --

       Line                                   Node      1H->0L      0L->1H       0L->Z       Z->0L       1H->Z       Z->H1     ExtMode  "Coverage"
--------------------------------------------------------------------------------------------------------------------------------------------------

========
(n*) - Number was not used in coverage calculations performed by extended toggle algorithms.

Extended Toggle Coverage Calculation Criteria:
-----------------------------------------------
	ExtMode 1: 0L->1H & 1H->0L & any one 'Z' transition (to/from 'Z').
	ExtMode 2: 0L->1H & 1H->0L & one transition to 'Z' & one transition from 'Z'.
	ExtMode 3: 0L->1H & 1H->0L & all 'Z' transitions.
========

Total Node Count     =          2 
Toggled Node Count   =          2 
Untoggled Node Count =          0 

Toggle Coverage      =     100.00% (4 of 4 bins)

=================================================================================
=== File: UART_interface.sv
=================================================================================
Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      22        22         0   100.00%

================================Statement Details================================

Statement Coverage for file UART_interface.sv --

    1                                                interface UART_interface (
    2                                                    input logic CLK
    3                                                );
    4                                                
    5                                                  // DUT pins
    6                                                  logic       Reset;
    7                                                  logic       rd_uart, wr_uart;
    8                                                  logic       rx;                 // TB -> DUT
    9                                                  logic [7:0] w_data;
    10                                                 logic [9:0] divsr;
    11                                               
    12                                                 logic       rx_empty, tx_full;
    13                                                 logic       tx;                 // DUT -> TB
    14                                                 logic [7:0] r_data;
    15                                                 logic       incorrect_send;
    16                                                 logic       tx_done, rx_done;
    17                                               
    18                                                 // Clocking blocks
    19              1                          1       clocking drv_cb @(posedge CLK);
    20                                                   default input #1step output #1step;
    21                                                   output Reset, rd_uart, wr_uart, w_data, divsr, rx;
    22              1                          1         input  rx_empty, tx_full, tx, r_data, incorrect_send, tx_done, rx_done;
    22              2                          1     
    22              3                          1     
    22              4                          1     
    22              5                          1     
    22              6                          1     
    22              7                          1     
    23                                                 endclocking
    24                                               
    25              1                          1       clocking mon_cb @(posedge CLK);
    26                                                   default input #1step output #1step;
    27              1                          1         input  Reset, rd_uart, wr_uart, w_data, divsr, rx;
    27              2                          1     
    27              3                          1     
    27              4                          1     
    27              5                          1     
    27              6                          1     
    28              1                          1         input  rx_empty, tx_full, tx, r_data, incorrect_send, tx_done, rx_done;
    28              2                          1     
    28              3                          1     
    28              4                          1     
    28              5                          1     
    28              6                          1     
    28              7                          1     
    29                                                 endclocking
    30                                               
    31                                                 // =========================
    32                                                 // Simple assertions
    33                                                 // =========================
    34                                                 property p_no_rd_when_empty;
    35                                                   @(posedge CLK) disable iff (Reset) !(rd_uart && rx_empty);
    36                                                 endproperty
    37                                                 a_no_rd_when_empty: assert property (p_no_rd_when_empty)
    38                                                   else $error("UART_IF ASSERT: rd_uart asserted while rx_empty=1");
    39                                               
    40                                                 property p_no_wr_when_full;
    41                                                   @(posedge CLK) disable iff (Reset) !(wr_uart && tx_full);
    42                                                 endproperty
    43                                                 a_no_wr_when_full: assert property (p_no_wr_when_full)
    44                                                   else $error("UART_IF ASSERT: wr_uart asserted while tx_full=1");
    45                                               
    46                                                 property p_tx_done_pulse;
    47                                                   @(posedge CLK) disable iff (Reset) tx_done |=> !tx_done;
    48                                                 endproperty
    49                                                 a_tx_done_pulse: assert property (p_tx_done_pulse)
    50                                                   else $warning("UART_IF WARN: tx_done is not a 1-cycle pulse");
    51                                               
    52                                                 property p_rx_done_pulse;
    53                                                   @(posedge CLK) disable iff (Reset) rx_done |=> !rx_done;
    54                                                 endproperty
    55                                                 a_rx_done_pulse: assert property (p_rx_done_pulse)
    56                                                   else $warning("UART_IF WARN: rx_done is not a 1-cycle pulse");
    57                                               
    58                                               endinterface

Toggle Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Toggles                        122        55        67    45.08%

================================Toggle Details================================

Toggle Coverage for File UART_interface.sv --

       Line                                   Node      1H->0L      0L->1H       0L->Z       Z->0L       1H->Z       Z->H1     ExtMode  "Coverage"
--------------------------------------------------------------------------------------------------------------------------------------------------
          6                                  Reset           1           0           0           0           0           0           3       16.66 
          8                                     rx           0           0           0           0           0           0           3        0.00 
         10                               divsr[9]           0           0           0           0           0           0           3        0.00 
         10                               divsr[8]           0           1           0           0           0           0           3       16.66 
         10                               divsr[7]           0           1           0           0           0           0           3       16.66 
         10                               divsr[6]           0           1           0           0           0           0           3       16.66 
         10                               divsr[5]           0           0           0           0           0           0           3        0.00 
         10                               divsr[4]           0           0           0           0           0           0           3        0.00 
         10                               divsr[3]           0           0           0           0           0           0           3        0.00 
         10                               divsr[2]           0           0           0           0           0           0           3        0.00 
         10                               divsr[1]           1           0           0           0           0           0           3       16.66 
         10                               divsr[0]           0           0           0           0           0           0           3        0.00 

========
(n*) - Number was not used in coverage calculations performed by extended toggle algorithms.

Extended Toggle Coverage Calculation Criteria:
-----------------------------------------------
	ExtMode 1: 0L->1H & 1H->0L & any one 'Z' transition (to/from 'Z').
	ExtMode 2: 0L->1H & 1H->0L & one transition to 'Z' & one transition from 'Z'.
	ExtMode 3: 0L->1H & 1H->0L & all 'Z' transitions.
========

Total Node Count     =         37 
Toggled Node Count   =         25 
Untoggled Node Count =         12 

Toggle Coverage      =      45.08% (55 of 122 bins)

=================================================================================
=== File: agent.sv
=================================================================================
Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      11         9         2    81.81%

================================Statement Details================================

Statement Coverage for file agent.sv --

    1                                                class agent extends uvm_agent;
    2               1                    ***0***       `uvm_component_utils(agent)
    2               2                    ***0***     
    2               3                          1     
    3                                                
    4                                                  sequencer UART_sequencer;
    5                                                  driver    UART_driver;
    6                                                  monitor   UART_monitor;
    7                                                
    8                                                  function new(string name = "agent", uvm_component parent);
    9               1                          1         super.new(name, parent);
    10                                                 endfunction
    11                                               
    12                                                 function void build_phase(uvm_phase phase);
    13              1                          1         super.build_phase(phase);
    14              1                          1         UART_sequencer = sequencer::type_id::create("UART_sequencer", this);
    15              1                          1         UART_driver    = driver   ::type_id::create("UART_driver",    this);
    16              1                          1         UART_monitor   = monitor  ::type_id::create("UART_monitor",   this);
    17                                                 endfunction
    18                                               
    19                                                 function void connect_phase(uvm_phase phase);
    20              1                          1         super.connect_phase(phase);
    21              1                          1         UART_driver.seq_item_port.connect(
    22                                                     UART_sequencer.seq_item_export
    23                                                   );
    24                                                 endfunction
    25                                               
    26                                                 task run_phase(uvm_phase phase);
    27              1                          1         super.run_phase(phase);
    28                                                 endtask
    29                                               
    30                                               endclass


=================================================================================
=== File: coverage_collector.sv
=================================================================================
Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      10         8         2    80.00%

================================Statement Details================================

Statement Coverage for file coverage_collector.sv --

    1                                                class coverage_collector extends uvm_subscriber #(UART_sequence_item);
    2               1                    ***0***       `uvm_component_utils(coverage_collector)
    2               2                    ***0***     
    2               3                          1     
    3                                                
    4                                                  UART_sequence_item item;
    5                                                  uvm_analysis_imp #(UART_sequence_item, coverage_collector) coverage_collector_in_imp;
    6                                                
    7                                                  covergroup UART_cg;
    8                                                    option.per_instance = 1;
    9                                                
    10                                                   KIND: coverpoint item.kind {
    11                                                     bins rst  = {UART_sequence_item::TR_RESET};
    12                                                     bins wr   = {UART_sequence_item::TR_WRITE};
    13                                                     bins rd   = {UART_sequence_item::TR_READ};
    14                                                   }
    15                                               
    16                                                   RESET: coverpoint item.Reset {
    17                                                     bins asserted   = {1'b1};
    18                                                     bins deasserted = {1'b0};
    19                                                   }
    20                                               
    21                                                   W_DATA: coverpoint item.w_data iff (item.kind == UART_sequence_item::TR_WRITE && item.Reset == 1'b0) {
    22                                                     bins all_zeros = {8'h00};
    23                                                     bins all_ones  = {8'hFF};
    24                                                     bins pat_aa    = {8'hAA};
    25                                                     bins pat_55    = {8'h55};
    26                                                     bins others    = default;
    27                                                   }
    28                                               
    29                                                   R_DATA: coverpoint item.r_data iff (item.kind == UART_sequence_item::TR_READ && item.Reset == 1'b0) {
    30                                                     bins all_zeros = {8'h00};
    31                                                     bins all_ones  = {8'hFF};
    32                                                     bins pat_aa    = {8'hAA};
    33                                                     bins pat_55    = {8'h55};
    34                                                     bins others    = default;
    35                                                   }
    36                                               
    37                                                   TX_FULL: coverpoint item.tx_full iff (item.kind == UART_sequence_item::TR_WRITE && item.Reset == 1'b0) {
    38                                                     bins not_full = {1'b0};
    39                                                     bins full     = {1'b1};
    40                                                   }
    41                                               
    42                                                   RX_EMPTY: coverpoint item.rx_empty iff (item.kind == UART_sequence_item::TR_READ && item.Reset == 1'b0) {
    43                                                     bins not_empty = {1'b0};
    44                                                     bins empty     = {1'b1};
    45                                                   }
    46                                               
    47                                                   INCORRECT_SEND: coverpoint item.incorrect_send iff (item.kind == UART_sequence_item::TR_READ && item.Reset == 1'b0) {
    48                                                     bins ok  = {1'b0};
    49                                                     bins err = {1'b1};
    50                                                   }
    51                                               
    52                                                   X_WDATA_FULL: cross W_DATA, TX_FULL;
    53                                                 endgroup
    54                                               
    55                                                 function new(string name = "coverage_collector", uvm_component parent);
    56              1                          1         super.new(name, parent);
    57              1                          1         UART_cg = new();
    58                                                 endfunction
    59                                               
    60                                                 function void build_phase (uvm_phase phase);
    61              1                          1         super.build_phase(phase);
    62              1                          1         coverage_collector_in_imp = new("coverage_collector_in_imp", this);
    63                                                 endfunction
    64                                               
    65                                                 function void write(UART_sequence_item t);
    66              1                        661         item = UART_sequence_item::type_id::create("item");
    67              1                        661         $cast(item, t);
    68              1                        661         UART_cg.sample();
    69                                                 endfunction
    70                                               
    71                                               endclass


=================================================================================
=== File: driver.sv
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                        18        10         8    55.55%

================================Branch Details================================

Branch Coverage for file driver.sv --

------------------------------------IF Branch------------------------------------
    13                                         1     Count coming in to IF
    13              1                    ***0***         if (!uvm_config_db#(virtual UART_interface)::get(this, "*", "intf", intf)) begin
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    14                                   ***0***     Count coming in to IF
    14              1                    ***0***           `uvm_error(get_type_name(), "virtual interface not set for driver")
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    43                                   ***0***     Count coming in to IF
    43              1                    ***0***         if (bad_parity) parity = ~parity;
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    95                                       463     Count coming in to IF
    95              1                          4         if (t.set_divsr) begin
                                             459     All False Count
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    101                                      463     Count coming in to IF
    101             1                          1         if (t.Reset) begin
                                             462     All False Count
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    107                                      462     Count coming in to IF
    107             1                    ***0***         if (t.inject_rx_frame) begin
                                             462     All False Count
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    109                                  ***0***     Count coming in to IF
    109             1                    ***0***           if (t.do_read) do_read_pop(t.read_delay_cycles);
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    114                                      462     Count coming in to IF
    114             1                        330         if (t.do_write) do_write_push(t.w_data);
                                             132     All False Count
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    115                                      462     Count coming in to IF
    115             1                        330         if (t.do_read)  do_read_pop(t.read_delay_cycles);
                                             132     All False Count
Branch totals: 2 hits of 2 branches = 100.00%


Condition Coverage:
    Enabled Coverage              Bins   Covered    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Conditions                       2         1         1    50.00%

================================Condition Details================================

Condition Coverage for file driver.sv --

----------------Focused Condition View-------------------
Line       74 Item    1  (this.intf.mon_cb.rx_empty !== 1'b0)
Condition totals: 1 of 1 input term covered = 100.00%

----------------Focused Condition View-------------------
Line       84 Item    1  (this.intf.mon_cb.tx_full === 1'b1)
Condition totals: 0 of 1 input term covered = 0.00%

                           Input Term   Covered  Reason for no coverage   Hint
                          -----------  --------  -----------------------  --------------
  (this.intf.mon_cb.tx_full === 1'b1)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target                             Non-masking condition(s)      
 ---------  ---------  --------------------                   -------------------------     
  Row   1:          1  (this.intf.mon_cb.tx_full === 1'b1)_0  -                             
  Row   2:    ***0***  (this.intf.mon_cb.tx_full === 1'b1)_1  -                             


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      67        41        26    61.19%

================================Statement Details================================

Statement Coverage for file driver.sv --

    1                                                class driver extends uvm_driver#(UART_sequence_item);
    2               1                    ***0***       `uvm_component_utils(driver)
    2               2                    ***0***     
    2               3                          1     
    3                                                
    4                                                  virtual UART_interface intf;
    5                                                  UART_sequence_item     item;
    6                                                
    7                                                  function new(string name = "driver", uvm_component parent);
    8               1                          1         super.new(name, parent);
    9                                                  endfunction
    10                                               
    11                                                 function void build_phase(uvm_phase phase);
    12              1                          1         super.build_phase(phase);
    13                                                   if (!uvm_config_db#(virtual UART_interface)::get(this, "*", "intf", intf)) begin
    14              1                    ***0***           `uvm_error(get_type_name(), "virtual interface not set for driver")
    15                                                   end
    16                                                 endfunction
    17                                               
    18                                                 // Wait N clock cycles (posedge)
    19                                                 task automatic wait_cycles(int unsigned n);
    20              1                          7         repeat (n) @(intf.drv_cb);
    20              2                          7     
    21                                                 endtask
    22                                               
    23                                                 // UART bit time = 16 ticks; tick period = (divsr+1) cycles
    24                                                 task automatic wait_bit_time();
    25                                                   int unsigned cycles;
    26              1                    ***0***         cycles = (intf.mon_cb.divsr + 1) * 16;
    27              1                    ***0***         repeat (cycles) @(intf.drv_cb);
    27              2                    ***0***     
    28                                                 endtask
    29                                               
    30                                                 task automatic apply_reset();
    31              1                          1         intf.drv_cb.wr_uart <= 1'b0;
    32              1                          1         intf.drv_cb.rd_uart <= 1'b0;
    33              1                          1         intf.drv_cb.rx      <= 1'b1;
    34              1                          1         intf.drv_cb.Reset   <= 1'b1;
    35              1                          1         wait_cycles(5);
    36              1                          1         intf.drv_cb.Reset   <= 1'b0;
    37              1                          1         wait_cycles(2);
    38                                                 endtask
    39                                               
    40                                                 task automatic drive_rx_frame(byte data, bit bad_parity, bit bad_stop);
    41                                                   bit parity;
    42              1                    ***0***         parity = ^data;                 // XOR parity
    43              1                    ***0***         if (bad_parity) parity = ~parity;
    44                                               
    45                                                   // idle
    46              1                    ***0***         intf.drv_cb.rx <= 1'b1;
    47              1                    ***0***         wait_bit_time();
    48                                               
    49                                                   // start bit
    50              1                    ***0***         intf.drv_cb.rx <= 1'b0;
    51              1                    ***0***         wait_bit_time();
    52                                               
    53                                                   // data bits (LSB first)
    54              1                    ***0***         for (int i = 0; i < 8; i++) begin
    54              2                    ***0***     
    55              1                    ***0***           intf.drv_cb.rx <= data[i];
    56              1                    ***0***           wait_bit_time();
    57                                                   end
    58                                               
    59                                                   // parity bit
    60              1                    ***0***         intf.drv_cb.rx <= parity;
    61              1                    ***0***         wait_bit_time();
    62                                               
    63                                                   // stop bit
    64              1                    ***0***         intf.drv_cb.rx <= (bad_stop ? 1'b0 : 1'b1);
    65              1                    ***0***         wait_bit_time();
    66                                               
    67                                                   // back to idle
    68              1                    ***0***         intf.drv_cb.rx <= 1'b1;
    69              1                    ***0***         wait_bit_time();
    70                                                 endtask
    71                                               
    72                                                 task automatic do_read_pop(int unsigned delay_cycles);
    73                                                   // Wait until RX has data
    74              1                    3048207         while (intf.mon_cb.rx_empty !== 1'b0) @(intf.drv_cb);
    74              2                    3047877     
    75              1                        330         wait_cycles(delay_cycles);
    76                                               
    77              1                        330         intf.drv_cb.rd_uart <= 1'b1;
    78              1                        330         @(intf.drv_cb);
    79              1                        330         intf.drv_cb.rd_uart <= 1'b0;
    80              1                        330         @(intf.drv_cb);
    81                                                 endtask
    82                                               
    83                                                 task automatic do_write_push(byte data);
    84              1                        330         while (intf.mon_cb.tx_full === 1'b1) @(intf.drv_cb);
    84              2                    ***0***     
    85                                               
    86              1                        330         intf.drv_cb.w_data  <= data;
    87              1                        330         intf.drv_cb.wr_uart <= 1'b1;
    88              1                        330         @(intf.drv_cb);
    89              1                        330         intf.drv_cb.wr_uart <= 1'b0;
    90              1                        330         @(intf.drv_cb);
    91                                                 endtask
    92                                               
    93                                                 task automatic drive_item(UART_sequence_item t);
    94                                                   // optional divsr override
    95                                                   if (t.set_divsr) begin
    96              1                          4           intf.drv_cb.divsr <= t.divsr;
    97              1                          4           @(intf.drv_cb);
    98                                                   end
    99                                               
    100                                                  // reset
    101                                                  if (t.Reset) begin
    102             1                          1           apply_reset();
    103             1                          1           return;
    104                                                  end
    105                                              
    106                                                  // external RX injection
    107                                                  if (t.inject_rx_frame) begin
    108             1                    ***0***           drive_rx_frame(t.w_data, t.bad_parity, t.bad_stop);
    109             1                    ***0***           if (t.do_read) do_read_pop(t.read_delay_cycles);
    110             1                    ***0***           return;
    111                                                  end
    112                                              
    113                                                  // normal path
    114             1                        330         if (t.do_write) do_write_push(t.w_data);
    115             1                        330         if (t.do_read)  do_read_pop(t.read_delay_cycles);
    116                                                endtask
    117                                              
    118                                                task run_phase(uvm_phase phase);
    119                                                  // set safe defaults
    120             1                          1         intf.drv_cb.wr_uart <= 1'b0;
    121             1                          1         intf.drv_cb.rd_uart <= 1'b0;
    122             1                          1         intf.drv_cb.rx      <= 1'b1;
    123             1                          1         intf.drv_cb.Reset   <= 1'b0;
    124             1                          1         intf.drv_cb.divsr   <= 10'd54;
    125             1                          1         intf.drv_cb.w_data  <= 8'h00;
    126                                              
    127             1                          1         forever begin
    128             1                        464           seq_item_port.get_next_item(item);
    129             1                        463           drive_item(item);
    130             1                        463           seq_item_port.item_done();
    131                                                  end
    132                                                endtask
    133                                              
    134                                              endclass


=================================================================================
=== File: env.sv
=================================================================================
Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      12        10         2    83.33%

================================Statement Details================================

Statement Coverage for file env.sv --

    1                                                class env extends uvm_env;
    2               1                    ***0***       `uvm_component_utils(env)
    2               2                    ***0***     
    2               3                          1     
    3                                                
    4                                                  agent              UART_agent;
    5                                                  scoreboard         UART_scoreboard;
    6                                                  coverage_collector UART_coverage_collector;
    7                                                
    8                                                  function new(string name = "env", uvm_component parent);
    9               1                          1         super.new(name, parent);
    10                                                 endfunction
    11                                               
    12                                                 function void build_phase(uvm_phase phase);
    13              1                          1         super.build_phase(phase);
    14                                               
    15              1                          1         UART_agent              = agent             ::type_id::create("UART_agent",              this);
    16              1                          1         UART_scoreboard         = scoreboard        ::type_id::create("UART_scoreboard",         this);
    17              1                          1         UART_coverage_collector = coverage_collector::type_id::create("UART_coverage_collector", this);
    18                                                 endfunction
    19                                               
    20                                                 function void connect_phase(uvm_phase phase);
    21              1                          1         super.connect_phase(phase);
    22                                               
    23              1                          1         UART_agent.UART_monitor.monitor_port.connect(UART_scoreboard.scoreboard_imp);
    24              1                          1         UART_agent.UART_monitor.monitor_port.connect(UART_coverage_collector.coverage_collector_in_imp);
    25                                                 endfunction
    26                                               
    27                                                 task run_phase(uvm_phase phase);
    28              1                          1         super.run_phase(phase);
    29                                                 endtask
    30                                               
    31                                               endclass


=================================================================================
=== File: monitor.sv
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                        14        10         4    71.42%

================================Branch Details================================

Branch Coverage for file monitor.sv --

------------------------------------IF Branch------------------------------------
    26                                         1     Count coming in to IF
    26              1                    ***0***         if (!uvm_config_db#(virtual UART_interface)::get(this, "*", "intf", intf)) begin
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    27                                   ***0***     Count coming in to IF
    27              1                    ***0***           `uvm_error(get_type_name(), "virtual interface not set for monitor")
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    42                                   3049207     Count coming in to IF
    42              1                          1           if (intf.Reset && !prev_reset) begin
                                         3049206     All False Count
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    55                                   3049207     Count coming in to IF
    55              1                          4           if (intf.Reset) begin
                                         3049203     All False Count
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    60                                   3049203     Count coming in to IF
    60              1                        330     		if (intf.wr_uart && (intf.tx_full == 1'b0)) begin
                                         3048873     All False Count
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    79                                   3049203     Count coming in to IF
    79              1                        330           if (intf.rd_uart && !rd_prev) begin
                                         3048873     All False Count
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    87                                       330     Count coming in to IF
    87              1                        330             if (exp_q.size() > 0) begin
    90              1                    ***0***             end else begin
Branch totals: 1 hit of 2 branches = 50.00%


Condition Coverage:
    Enabled Coverage              Bins   Covered    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Conditions                       7         4         3    57.14%

================================Condition Details================================

Condition Coverage for file monitor.sv --

----------------Focused Condition View-------------------
Line       42 Item    1  (this.intf.Reset && ~this.prev_reset)
Condition totals: 2 of 2 input terms covered = 100.00%

----------------Focused Condition View-------------------
Line       60 Item    1  (this.intf.wr_uart && ~this.intf.tx_full)
Condition totals: 1 of 2 input terms covered = 50.00%

         Input Term   Covered  Reason for no coverage   Hint
        -----------  --------  -----------------------  --------------
  this.intf.wr_uart         Y
  this.intf.tx_full         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  this.intf.wr_uart_0   -                             
  Row   2:          1  this.intf.wr_uart_1   ~this.intf.tx_full            
  Row   3:          1  this.intf.tx_full_0   this.intf.wr_uart             
  Row   4:    ***0***  this.intf.tx_full_1   this.intf.wr_uart             

----------------Focused Condition View-------------------
Line       79 Item    1  (this.intf.rd_uart && ~this.rd_prev)
Condition totals: 1 of 2 input terms covered = 50.00%

         Input Term   Covered  Reason for no coverage   Hint
        -----------  --------  -----------------------  --------------
  this.intf.rd_uart         Y
       this.rd_prev         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  this.intf.rd_uart_0   -                             
  Row   2:          1  this.intf.rd_uart_1   ~this.rd_prev                 
  Row   3:          1  this.rd_prev_0        this.intf.rd_uart             
  Row   4:    ***0***  this.rd_prev_1        this.intf.rd_uart             

----------------Focused Condition View-------------------
Line       87 Item    1  (size(this.exp_q) > 0)
Condition totals: 0 of 1 input term covered = 0.00%

              Input Term   Covered  Reason for no coverage   Hint
             -----------  --------  -----------------------  --------------
  (size(this.exp_q) > 0)         N  '_0' not hit             Hit '_0'

     Rows:       Hits  FEC Target                Non-masking condition(s)      
 ---------  ---------  --------------------      -------------------------     
  Row   1:    ***0***  (size(this.exp_q) > 0)_0  -                             
  Row   2:          1  (size(this.exp_q) > 0)_1  -                             


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      46        41         5    89.13%

================================Statement Details================================

Statement Coverage for file monitor.sv --

    1                                                class monitor extends uvm_monitor;
    2               1                    ***0***       `uvm_component_utils(monitor)
    2               2                    ***0***     
    2               3                          1     
    3                                                
    4                                                  virtual UART_interface intf;
    5                                                  uvm_analysis_port #(UART_sequence_item) monitor_port;
    6                                                
    7                                                  // Expected queue: push on WR, pop on RD
    8                                                  // Pairs TX writes with later RX reads (LOOPBACK)
    9                                                  byte exp_q[$];
    10                                               
    11                                                 // reset edge detect (emit one TR_RESET per reset assertion)
    12                                                 bit prev_reset;
    13                                               
    14                                                 // rd_uart edge detect (avoid double count if rd held > 1 cycle)
    15                                                 bit rd_prev;
    16                                               
    17                                                 function new(string name = "monitor", uvm_component parent);
    18              1                          1         super.new(name, parent);
    19              1                          1         monitor_port = new("monitor_port", this);
    20              1                          1         prev_reset = 0;
    21              1                          1         rd_prev    = 0;
    22                                                 endfunction
    23                                               
    24                                                 function void build_phase(uvm_phase phase);
    25              1                          1         super.build_phase(phase);
    26                                                   if (!uvm_config_db#(virtual UART_interface)::get(this, "*", "intf", intf)) begin
    27              1                    ***0***           `uvm_error(get_type_name(), "virtual interface not set for monitor")
    28                                                   end
    29                                                 endfunction
    30                                               
    31                                                 task run_phase(uvm_phase phase);
    32                                                   UART_sequence_item tr;
    33                                               
    34                                                   // IMPORTANT:
    35                                                   // DUT RX FIFO uses asynchronous read: r_data = mem[r_addr]
    36                                                   // Sampling at posedge with clocking input #1step can see r_addr AFTER pointer update -> off-by-one.
    37                                                   // Fix: sample on negedge while rd_uart is stable and BEFORE the consuming posedge.
    38              1                          1         forever begin
    39              1                    3049208           @(negedge intf.CLK);
    40                                               
    41                                                     // reset assertion edge: clear expected queue + emit TR_RESET once
    42                                                     if (intf.Reset && !prev_reset) begin
    43              1                          1             exp_q.delete();
    44              1                          1             rd_prev = 0;
    45                                               
    46              1                          1             tr = UART_sequence_item::type_id::create("tr_reset", this);
    47              1                          1             tr.kind         = UART_sequence_item::TR_RESET;
    48              1                          1             tr.Reset        = 1'b1;
    49              1                          1             tr.check_enable = 1'b0;
    50              1                          1             monitor_port.write(tr);
    51                                                     end
    52              1                    3049207           prev_reset = intf.Reset;
    53                                               
    54                                                     // skip while reset active
    55                                                     if (intf.Reset) begin
    56              1                          4             continue;
    57                                                     end
    58                                               
    59                                                     // WR event (capture and push expected)  -- ONLY when accepted
    60                                               		if (intf.wr_uart && (intf.tx_full == 1'b0)) begin
    61              1                        330     		  exp_q.push_back(intf.w_data);
    62                                               
    63              1                        330     		  tr = UART_sequence_item::type_id::create("tr_wr", this);
    64              1                        330     		  tr.kind   = UART_sequence_item::TR_WRITE;
    65              1                        330     		  tr.Reset  = 1'b0;
    66              1                        330     		  tr.w_data = intf.w_data;
    67                                               
    68              1                        330     		  tr.tx_full        = intf.tx_full;
    69              1                        330     		  tr.rx_empty       = intf.rx_empty;
    70              1                        330     		  tr.incorrect_send = intf.incorrect_send;
    71              1                        330     		  tr.tx_done        = intf.tx_done;
    72              1                        330     		  tr.rx_done        = intf.rx_done;
    73                                               
    74              1                        330     		  monitor_port.write(tr);
    75                                               		end
    76                                               
    77                                               
    78                                                     // RD event (edge detect)
    79                                                     if (intf.rd_uart && !rd_prev) begin
    80              1                        330             tr = UART_sequence_item::type_id::create("tr_rd", this);
    81              1                        330             tr.kind  = UART_sequence_item::TR_READ;
    82              1                        330             tr.Reset = 1'b0;
    83                                               
    84                                                       // Capture r_data at negedge (pre-consume posedge) -> correct FIFO element
    85              1                        330             tr.r_data = intf.r_data;
    86                                               
    87                                                       if (exp_q.size() > 0) begin
    88              1                        330               tr.w_data       = exp_q.pop_front();
    89              1                        330               tr.check_enable = 1'b1;
    90                                                       end else begin
    91              1                    ***0***               tr.w_data       = 8'hxx;
    92              1                    ***0***               tr.check_enable = 1'b0;
    93                                                       end
    94                                               
    95              1                        330             tr.tx_full        = intf.tx_full;
    96              1                        330             tr.rx_empty       = intf.rx_empty;
    97              1                        330             tr.incorrect_send = intf.incorrect_send;
    98              1                        330             tr.tx_done        = intf.tx_done;
    99              1                        330             tr.rx_done        = intf.rx_done;
    100                                              
    101             1                        330             monitor_port.write(tr);
    102                                                    end
    103             1                    3049203           rd_prev = intf.rd_uart;
    104                                                  end
    105                                                endtask
    106                                              
    107                                              endclass


=================================================================================
=== File: scoreboard.sv
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                        20         8        12    40.00%

================================Branch Details================================

Branch Coverage for file scoreboard.sv --

------------------------------------IF Branch------------------------------------
    16                                         1     Count coming in to IF
    16              1                          1         `uvm_info(get_type_name(), "in build_phase of scoreboard", UVM_LOW)
                                         ***0***     All False Count
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    29                                       661     Count coming in to IF
    29              1                        331         if (item.kind != UART_sequence_item::TR_READ) begin
                                             330     All False Count
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    33                                       330     Count coming in to IF
    33              1                    ***0***         if (item.Reset) begin
                                             330     All False Count
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    34                                   ***0***     Count coming in to IF
    34              1                    ***0***           `uvm_info(get_type_name(), "Reset observed - skip compare", UVM_LOW)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    38                                       330     Count coming in to IF
    38              1                    ***0***         if (!item.check_enable) begin
                                             330     All False Count
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    39                                   ***0***     Count coming in to IF
    39              1                    ***0***           `uvm_info(get_type_name(), "No expected data - skip compare", UVM_LOW)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    43                                       330     Count coming in to IF
    43              1                        330         if (item.w_data == item.r_data) begin
    48              1                    ***0***         else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    45                                       330     Count coming in to IF
    45              1                        330           `uvm_info(get_type_name(),
                                         ***0***     All False Count
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    50                                   ***0***     Count coming in to IF
    50              1                    ***0***           `uvm_error(get_type_name(),
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    58                                         1     Count coming in to IF
    58              1                          1         `uvm_info(get_type_name(),
                                         ***0***     All False Count
Branch totals: 1 hit of 2 branches = 50.00%


Condition Coverage:
    Enabled Coverage              Bins   Covered    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Conditions                       2         1         1    50.00%

================================Condition Details================================

Condition Coverage for file scoreboard.sv --

----------------Focused Condition View-------------------
Line       29 Item    1  (item.kind != TR_READ)
Condition totals: 1 of 1 input term covered = 100.00%

----------------Focused Condition View-------------------
Line       43 Item    1  (item.w_data == item.r_data)
Condition totals: 0 of 1 input term covered = 0.00%

                    Input Term   Covered  Reason for no coverage   Hint
                   -----------  --------  -----------------------  --------------
  (item.w_data == item.r_data)         N  '_0' not hit             Hit '_0'

     Rows:       Hits  FEC Target                      Non-masking condition(s)      
 ---------  ---------  --------------------            -------------------------     
  Row   1:    ***0***  (item.w_data == item.r_data)_0  -                             
  Row   2:          1  (item.w_data == item.r_data)_1  -                             


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      21        13         8    61.90%

================================Statement Details================================

Statement Coverage for file scoreboard.sv --

    1                                                class scoreboard extends uvm_scoreboard;
    2               1                    ***0***       `uvm_component_utils(scoreboard)
    2               2                    ***0***     
    2               3                        665     
    3                                                
    4                                                  // Must match env.sv: UART_scoreboard.scoreboard_imp
    5                                                  uvm_analysis_imp #(UART_sequence_item, scoreboard) scoreboard_imp;
    6                                                
    7               1                          1       int match = 0;
    8               1                          1       int mismatch = 0;
    9                                                
    10                                                 function new(string name = "scoreboard", uvm_component parent);
    11              1                          1         super.new(name, parent);
    12                                                 endfunction
    13                                               
    14                                                 function void build_phase(uvm_phase phase);
    15              1                          1         super.build_phase(phase);
    16              1                          1         `uvm_info(get_type_name(), "in build_phase of scoreboard", UVM_LOW)
    17              1                          1         scoreboard_imp = new("scoreboard_imp", this);
    18                                                 endfunction
    19                                               
    20                                                 // Analysis callback (MUST be function)
    21                                                 function void write(UART_sequence_item item);
    22              1                        661         compare(item);
    23                                                 endfunction
    24                                               
    25                                                 // MUST be function (NOT task) because it is called from write()
    26                                                 function void compare(UART_sequence_item item);
    27                                               
    28                                                   // Nu sequence_item ca my c kind/check_enable/Reset nh bn tao  xut:
    29                                                   if (item.kind != UART_sequence_item::TR_READ) begin
    30              1                        331           return;
    31                                                   end
    32                                               
    33                                                   if (item.Reset) begin
    34              1                    ***0***           `uvm_info(get_type_name(), "Reset observed - skip compare", UVM_LOW)
    35              1                    ***0***           return;
    36                                                   end
    37                                               
    38                                                   if (!item.check_enable) begin
    39              1                    ***0***           `uvm_info(get_type_name(), "No expected data - skip compare", UVM_LOW)
    40              1                    ***0***           return;
    41                                                   end
    42                                               
    43                                                   if (item.w_data == item.r_data) begin
    44              1                        330           match++;
    45              1                        330           `uvm_info(get_type_name(),
    46                                                       $sformatf("MATCH exp=0x%02h got=0x%02h", item.w_data, item.r_data), UVM_LOW)
    47                                                   end
    48                                                   else begin
    49              1                    ***0***           mismatch++;
    50              1                    ***0***           `uvm_error(get_type_name(),
    51                                                       $sformatf("MISMATCH exp=0x%02h got=0x%02h", item.w_data, item.r_data))
    52                                                   end
    53                                               
    54                                                 endfunction
    55                                               
    56                                                 function void report_phase(uvm_phase phase);
    57              1                          1         super.report_phase(phase);
    58              1                          1         `uvm_info(get_type_name(),
    59                                                     $sformatf("SCOREBOARD SUMMARY: match=%0d mismatch=%0d", match, mismatch),
    60                                                     UVM_NONE)
    61                                                 endfunction
    62                                               
    63                                               endclass


=================================================================================
=== File: sequence.sv
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                        84         2        82     2.38%

================================Branch Details================================

Branch Coverage for file sequence.sv --

------------------------------------IF Branch------------------------------------
    2                                    ***0***     Count coming in to IF
    2               1                    ***0***       `uvm_object_utils(base_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2                                    ***0***     Count coming in to IF
    2               2                    ***0***       `uvm_object_utils(base_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2                                    ***0***     Count coming in to IF
    2               3                    ***0***       `uvm_object_utils(base_sequence)
    2               4                    ***0***       `uvm_object_utils(base_sequence)
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2                                    ***0***     Count coming in to IF
    2               5                    ***0***       `uvm_object_utils(base_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2                                    ***0***     Count coming in to IF
    2               6                    ***0***       `uvm_object_utils(base_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    10                                   ***0***     Count coming in to IF
    10              1                    ***0***       `uvm_object_utils(reset_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    10                                   ***0***     Count coming in to IF
    10              2                    ***0***       `uvm_object_utils(reset_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    10                                   ***0***     Count coming in to IF
    10              3                    ***0***       `uvm_object_utils(reset_sequence)
    10              4                    ***0***       `uvm_object_utils(reset_sequence)
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    10                                   ***0***     Count coming in to IF
    10              5                    ***0***       `uvm_object_utils(reset_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    10                                   ***0***     Count coming in to IF
    10              6                    ***0***       `uvm_object_utils(reset_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    25                                   ***0***     Count coming in to IF
    25              1                    ***0***       `uvm_object_utils(run_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    25                                   ***0***     Count coming in to IF
    25              2                    ***0***       `uvm_object_utils(run_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    25                                   ***0***     Count coming in to IF
    25              3                    ***0***       `uvm_object_utils(run_sequence)
    25              4                    ***0***       `uvm_object_utils(run_sequence)
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    25                                   ***0***     Count coming in to IF
    25              5                    ***0***       `uvm_object_utils(run_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    25                                   ***0***     Count coming in to IF
    25              6                    ***0***       `uvm_object_utils(run_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    40                                   ***0***     Count coming in to IF
    40              1                    ***0***       `uvm_object_utils(all_one_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    40                                   ***0***     Count coming in to IF
    40              2                    ***0***       `uvm_object_utils(all_one_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    40                                   ***0***     Count coming in to IF
    40              3                    ***0***       `uvm_object_utils(all_one_sequence)
    40              4                    ***0***       `uvm_object_utils(all_one_sequence)
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    40                                   ***0***     Count coming in to IF
    40              5                    ***0***       `uvm_object_utils(all_one_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    40                                   ***0***     Count coming in to IF
    40              6                    ***0***       `uvm_object_utils(all_one_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    56                                   ***0***     Count coming in to IF
    56              1                    ***0***       `uvm_object_utils(all_zero_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    56                                   ***0***     Count coming in to IF
    56              2                    ***0***       `uvm_object_utils(all_zero_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    56                                   ***0***     Count coming in to IF
    56              3                    ***0***       `uvm_object_utils(all_zero_sequence)
    56              4                    ***0***       `uvm_object_utils(all_zero_sequence)
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    56                                   ***0***     Count coming in to IF
    56              5                    ***0***       `uvm_object_utils(all_zero_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    56                                   ***0***     Count coming in to IF
    56              6                    ***0***       `uvm_object_utils(all_zero_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    73                                   ***0***     Count coming in to IF
    73              1                    ***0***       `uvm_object_utils(burst_no_read_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    73                                   ***0***     Count coming in to IF
    73              2                    ***0***       `uvm_object_utils(burst_no_read_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    73                                   ***0***     Count coming in to IF
    73              3                    ***0***       `uvm_object_utils(burst_no_read_sequence)
    73              4                    ***0***       `uvm_object_utils(burst_no_read_sequence)
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    73                                   ***0***     Count coming in to IF
    73              5                    ***0***       `uvm_object_utils(burst_no_read_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    73                                   ***0***     Count coming in to IF
    73              6                    ***0***       `uvm_object_utils(burst_no_read_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    87                                         4     Count coming in to IF
    87              1                          4         if (slow_baud) begin
                                         ***0***     All False Count
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    104                                      128     Count coming in to IF
    104             1                        128           if (use_random) it.w_data = $urandom_range(0, 255);
    105             1                    ***0***           else it.w_data = i[7:0];
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    113                                  ***0***     Count coming in to IF
    113             1                    ***0***       `uvm_object_utils(drain_read_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    113                                  ***0***     Count coming in to IF
    113             2                    ***0***       `uvm_object_utils(drain_read_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    113                                  ***0***     Count coming in to IF
    113             3                    ***0***       `uvm_object_utils(drain_read_sequence)
    113             4                    ***0***       `uvm_object_utils(drain_read_sequence)
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    113                                  ***0***     Count coming in to IF
    113             5                    ***0***       `uvm_object_utils(drain_read_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    113                                  ***0***     Count coming in to IF
    113             6                    ***0***       `uvm_object_utils(drain_read_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    136                                  ***0***     Count coming in to IF
    136             1                    ***0***       `uvm_object_utils(rx_bad_parity_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    136                                  ***0***     Count coming in to IF
    136             2                    ***0***       `uvm_object_utils(rx_bad_parity_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    136                                  ***0***     Count coming in to IF
    136             3                    ***0***       `uvm_object_utils(rx_bad_parity_sequence)
    136             4                    ***0***       `uvm_object_utils(rx_bad_parity_sequence)
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    136                                  ***0***     Count coming in to IF
    136             5                    ***0***       `uvm_object_utils(rx_bad_parity_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    136                                  ***0***     Count coming in to IF
    136             6                    ***0***       `uvm_object_utils(rx_bad_parity_sequence)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%


Condition Coverage:
    Enabled Coverage              Bins   Covered    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Conditions                      16         0        16     0.00%

================================Condition Details================================

Condition Coverage for file sequence.sv --

----------------Focused Condition View-------------------
Line       2 Item    1  (name != 0)
Condition totals: 0 of 1 input term covered = 0.00%

   Input Term   Covered  Reason for no coverage   Hint
  -----------  --------  -----------------------  --------------
  (name != 0)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  (name != 0)_0         -                             
  Row   2:    ***0***  (name != 0)_1         -                             

----------------Focused Condition View-------------------
Line       2 Item    2  (tmp_data__ != null)
Condition totals: 0 of 1 input term covered = 0.00%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (tmp_data__ != null)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:    ***0***  (tmp_data__ != null)_0  -                             
  Row   2:    ***0***  (tmp_data__ != null)_1  -                             

----------------Focused Condition View-------------------
Line       10 Item    1  (name != 0)
Condition totals: 0 of 1 input term covered = 0.00%

   Input Term   Covered  Reason for no coverage   Hint
  -----------  --------  -----------------------  --------------
  (name != 0)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  (name != 0)_0         -                             
  Row   2:    ***0***  (name != 0)_1         -                             

----------------Focused Condition View-------------------
Line       10 Item    2  (tmp_data__ != null)
Condition totals: 0 of 1 input term covered = 0.00%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (tmp_data__ != null)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:    ***0***  (tmp_data__ != null)_0  -                             
  Row   2:    ***0***  (tmp_data__ != null)_1  -                             

----------------Focused Condition View-------------------
Line       25 Item    1  (name != 0)
Condition totals: 0 of 1 input term covered = 0.00%

   Input Term   Covered  Reason for no coverage   Hint
  -----------  --------  -----------------------  --------------
  (name != 0)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  (name != 0)_0         -                             
  Row   2:    ***0***  (name != 0)_1         -                             

----------------Focused Condition View-------------------
Line       25 Item    2  (tmp_data__ != null)
Condition totals: 0 of 1 input term covered = 0.00%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (tmp_data__ != null)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:    ***0***  (tmp_data__ != null)_0  -                             
  Row   2:    ***0***  (tmp_data__ != null)_1  -                             

----------------Focused Condition View-------------------
Line       40 Item    1  (name != 0)
Condition totals: 0 of 1 input term covered = 0.00%

   Input Term   Covered  Reason for no coverage   Hint
  -----------  --------  -----------------------  --------------
  (name != 0)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  (name != 0)_0         -                             
  Row   2:    ***0***  (name != 0)_1         -                             

----------------Focused Condition View-------------------
Line       40 Item    2  (tmp_data__ != null)
Condition totals: 0 of 1 input term covered = 0.00%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (tmp_data__ != null)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:    ***0***  (tmp_data__ != null)_0  -                             
  Row   2:    ***0***  (tmp_data__ != null)_1  -                             

----------------Focused Condition View-------------------
Line       56 Item    1  (name != 0)
Condition totals: 0 of 1 input term covered = 0.00%

   Input Term   Covered  Reason for no coverage   Hint
  -----------  --------  -----------------------  --------------
  (name != 0)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  (name != 0)_0         -                             
  Row   2:    ***0***  (name != 0)_1         -                             

----------------Focused Condition View-------------------
Line       56 Item    2  (tmp_data__ != null)
Condition totals: 0 of 1 input term covered = 0.00%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (tmp_data__ != null)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:    ***0***  (tmp_data__ != null)_0  -                             
  Row   2:    ***0***  (tmp_data__ != null)_1  -                             

----------------Focused Condition View-------------------
Line       73 Item    1  (name != 0)
Condition totals: 0 of 1 input term covered = 0.00%

   Input Term   Covered  Reason for no coverage   Hint
  -----------  --------  -----------------------  --------------
  (name != 0)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  (name != 0)_0         -                             
  Row   2:    ***0***  (name != 0)_1         -                             

----------------Focused Condition View-------------------
Line       73 Item    2  (tmp_data__ != null)
Condition totals: 0 of 1 input term covered = 0.00%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (tmp_data__ != null)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:    ***0***  (tmp_data__ != null)_0  -                             
  Row   2:    ***0***  (tmp_data__ != null)_1  -                             

----------------Focused Condition View-------------------
Line       113 Item    1  (name != 0)
Condition totals: 0 of 1 input term covered = 0.00%

   Input Term   Covered  Reason for no coverage   Hint
  -----------  --------  -----------------------  --------------
  (name != 0)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  (name != 0)_0         -                             
  Row   2:    ***0***  (name != 0)_1         -                             

----------------Focused Condition View-------------------
Line       113 Item    2  (tmp_data__ != null)
Condition totals: 0 of 1 input term covered = 0.00%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (tmp_data__ != null)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:    ***0***  (tmp_data__ != null)_0  -                             
  Row   2:    ***0***  (tmp_data__ != null)_1  -                             

----------------Focused Condition View-------------------
Line       136 Item    1  (name != 0)
Condition totals: 0 of 1 input term covered = 0.00%

   Input Term   Covered  Reason for no coverage   Hint
  -----------  --------  -----------------------  --------------
  (name != 0)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  (name != 0)_0         -                             
  Row   2:    ***0***  (name != 0)_1         -                             

----------------Focused Condition View-------------------
Line       136 Item    2  (tmp_data__ != null)
Condition totals: 0 of 1 input term covered = 0.00%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (tmp_data__ != null)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:    ***0***  (tmp_data__ != null)_0  -                             
  Row   2:    ***0***  (tmp_data__ != null)_1  -                             


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                     168        70        98    41.66%

================================Statement Details================================

Statement Coverage for file sequence.sv --

    1                                                class base_sequence extends uvm_sequence#(UART_sequence_item);
    2               1                    ***0***       `uvm_object_utils(base_sequence)
    2               2                    ***0***     
    2               3                    ***0***     
    2               4                    ***0***     
    2               5                    ***0***     
    2               6                    ***0***     
    2               7                    ***0***     
    2               8                    ***0***     
    2               9                    ***0***     
    2              10                    ***0***     
    3                                                
    4                                                  function new(string name = "base_sequence");
    5               1                        211         super.new(name);
    6                                                  endfunction
    7                                                endclass
    8                                                
    9                                                class reset_sequence extends base_sequence;
    10              1                    ***0***       `uvm_object_utils(reset_sequence)
    10              2                    ***0***     
    10              3                    ***0***     
    10              4                    ***0***     
    10              5                    ***0***     
    10              6                          1     
    10              7                    ***0***     
    10              8                    ***0***     
    10              9                    ***0***     
    10             10                    ***0***     
    11              1                          1       function new(string name = "reset_sequence"); super.new(name); endfunction
    12                                               
    13                                                 task body();
    14                                                   UART_sequence_item it;
    15              1                          1         it = UART_sequence_item::type_id::create("it_reset");
    16              1                          1         start_item(it);
    17              1                          1         it.Reset = 1'b1;
    18              1                          1         it.do_write = 1'b0;
    19              1                          1         it.do_read  = 1'b0;
    20              1                          1         finish_item(it);
    21                                                 endtask
    22                                               endclass
    23                                               
    24                                               class run_sequence extends base_sequence;
    25              1                    ***0***       `uvm_object_utils(run_sequence)
    25              2                    ***0***     
    25              3                    ***0***     
    25              4                    ***0***     
    25              5                    ***0***     
    25              6                        200     
    25              7                    ***0***     
    25              8                    ***0***     
    25              9                    ***0***     
    25             10                    ***0***     
    26              1                        200       function new(string name = "run_sequence"); super.new(name); endfunction
    27                                               
    28                                                 task body();
    29                                                   UART_sequence_item it;
    30              1                        200         it = UART_sequence_item::type_id::create("it_rand");
    31              1                        200         start_item(it);
    32                                                   assert(it.randomize() with { Reset == 1'b0; });
    33              1                        200         it.do_write = 1'b1;
    34              1                        200         it.do_read  = 1'b1;
    35              1                        200         finish_item(it);
    36                                                 endtask
    37                                               endclass
    38                                               
    39                                               class all_one_sequence extends base_sequence;
    40              1                    ***0***       `uvm_object_utils(all_one_sequence)
    40              2                    ***0***     
    40              3                    ***0***     
    40              4                    ***0***     
    40              5                    ***0***     
    40              6                          1     
    40              7                    ***0***     
    40              8                    ***0***     
    40              9                    ***0***     
    40             10                    ***0***     
    41              1                          1       function new(string name = "all_one_sequence"); super.new(name); endfunction
    42                                               
    43                                                 task body();
    44                                                   UART_sequence_item it;
    45              1                          1         it = UART_sequence_item::type_id::create("it_ones");
    46              1                          1         start_item(it);
    47              1                          1         it.Reset = 1'b0;
    48              1                          1         it.w_data = 8'hFF;
    49              1                          1         it.do_write = 1'b1;
    50              1                          1         it.do_read  = 1'b1;
    51              1                          1         finish_item(it);
    52                                                 endtask
    53                                               endclass
    54                                               
    55                                               class all_zero_sequence extends base_sequence;
    56              1                    ***0***       `uvm_object_utils(all_zero_sequence)
    56              2                    ***0***     
    56              3                    ***0***     
    56              4                    ***0***     
    56              5                    ***0***     
    56              6                          1     
    56              7                    ***0***     
    56              8                    ***0***     
    56              9                    ***0***     
    56             10                    ***0***     
    57              1                          1       function new(string name = "all_zero_sequence"); super.new(name); endfunction
    58                                               
    59                                                 task body();
    60                                                   UART_sequence_item it;
    61              1                          1         it = UART_sequence_item::type_id::create("it_zeros");
    62              1                          1         start_item(it);
    63              1                          1         it.Reset = 1'b0;
    64              1                          1         it.w_data = 8'h00;
    65              1                          1         it.do_write = 1'b1;
    66              1                          1         it.do_read  = 1'b1;
    67              1                          1         finish_item(it);
    68                                                 endtask
    69                                               endclass
    70                                               
    71                                               // Burst many writes without reading (fills RX FIFO, can hit TX full with slow baud)
    72                                               class burst_no_read_sequence extends base_sequence;
    73              1                    ***0***       `uvm_object_utils(burst_no_read_sequence)
    73              2                    ***0***     
    73              3                    ***0***     
    73              4                    ***0***     
    73              5                    ***0***     
    73              6                          4     
    73              7                    ***0***     
    73              8                    ***0***     
    73              9                    ***0***     
    73             10                    ***0***     
    74                                               
    75              1                          4       int unsigned n_bytes    = 64;
    76              1                          4       bit          use_random = 1'b1;
    77                                               
    78              1                          4       bit          slow_baud  = 1'b1;
    79              1                          4       logic [9:0]  slow_divsr = 10'd500;
    80                                               
    81              1                          4       function new(string name = "burst_no_read_sequence"); super.new(name); endfunction
    82                                               
    83                                                 task body();
    84                                                   UART_sequence_item it;
    85                                               
    86                                                   // Optional: slow down baud rate so TX drains slower -> tx_full more likely to assert
    87                                                   if (slow_baud) begin
    88              1                          4           it = UART_sequence_item::type_id::create("it_cfg_divsr");
    89              1                          4           start_item(it);
    90              1                          4           it.Reset     = 1'b0;
    91              1                          4           it.do_write  = 1'b0;
    92              1                          4           it.do_read   = 1'b0;
    93              1                          4           it.set_divsr = 1'b1;
    94              1                          4           it.divsr     = slow_divsr;
    95              1                          4           finish_item(it);
    96                                                   end
    97                                               
    98              1                          4         for (int i = 0; i < n_bytes; i++) begin
    98              2                        128     
    99              1                        128           it = UART_sequence_item::type_id::create($sformatf("it_burst_%0d", i));
    100             1                        128           start_item(it);
    101             1                        128           it.Reset    = 1'b0;
    102             1                        128           it.do_write = 1'b1;
    103             1                        128           it.do_read  = 1'b0;
    104             1                        128           if (use_random) it.w_data = $urandom_range(0, 255);
    105             1                    ***0***           else it.w_data = i[7:0];
    106             1                        128           finish_item(it);
    107                                                  end
    108                                                endtask
    109                                              endclass
    110                                              
    111                                              // Read-only drain sequence: pop N bytes later (monitor pairs expected from earlier writes)
    112                                              class drain_read_sequence extends base_sequence;
    113             1                    ***0***       `uvm_object_utils(drain_read_sequence)
    113             2                    ***0***     
    113             3                    ***0***     
    113             4                    ***0***     
    113             5                    ***0***     
    113             6                          4     
    113             7                    ***0***     
    113             8                    ***0***     
    113             9                    ***0***     
    113            10                    ***0***     
    114                                              
    115             1                          4       int unsigned n_reads = 64;
    116             1                          4       int unsigned read_delay_cycles = 0;
    117                                              
    118             1                          4       function new(string name = "drain_read_sequence"); super.new(name); endfunction
    119                                              
    120                                                task body();
    121                                                  UART_sequence_item it;
    122             1                          4         for (int i = 0; i < n_reads; i++) begin
    122             2                        128     
    123             1                        128           it = UART_sequence_item::type_id::create($sformatf("it_drain_%0d", i));
    124             1                        128           start_item(it);
    125             1                        128           it.Reset = 1'b0;
    126             1                        128           it.do_write = 1'b0;
    127             1                        128           it.do_read  = 1'b1;
    128             1                        128           it.read_delay_cycles = read_delay_cycles;
    129             1                        128           finish_item(it);
    130                                                  end
    131                                                endtask
    132                                              endclass
    133                                              
    134                                              // Negative test (external RX): inject bad parity frames and optionally read them
    135                                              class rx_bad_parity_sequence extends base_sequence;
    136             1                    ***0***       `uvm_object_utils(rx_bad_parity_sequence)
    136             2                    ***0***     
    136             3                    ***0***     
    136             4                    ***0***     
    136             5                    ***0***     
    136             6                    ***0***     
    136             7                    ***0***     
    136             8                    ***0***     
    136             9                    ***0***     
    136            10                    ***0***     
    137                                              
    138             1                    ***0***       int unsigned n_frames = 5;
    139             1                    ***0***       logic [9:0]  divsr    = 10'd54;
    140                                              
    141             1                    ***0***       function new(string name = "rx_bad_parity_sequence"); super.new(name); endfunction
    142                                              
    143                                                task body();
    144                                                  UART_sequence_item it;
    145                                              
    146                                                  // set divsr (optional)
    147             1                    ***0***         it = UART_sequence_item::type_id::create("it_cfg_divsr_badpar");
    148             1                    ***0***         start_item(it);
    149             1                    ***0***         it.Reset     = 1'b0;
    150             1                    ***0***         it.do_write  = 1'b0;
    151             1                    ***0***         it.do_read   = 1'b0;
    152             1                    ***0***         it.set_divsr = 1'b1;
    153             1                    ***0***         it.divsr     = divsr;
    154             1                    ***0***         finish_item(it);
    155                                              
    156             1                    ***0***         for (int i = 0; i < n_frames; i++) begin
    156             2                    ***0***     
    157             1                    ***0***           it = UART_sequence_item::type_id::create($sformatf("it_badpar_%0d", i));
    158             1                    ***0***           start_item(it);
    159             1                    ***0***           it.Reset          = 1'b0;
    160             1                    ***0***           it.do_write       = 1'b0;
    161             1                    ***0***           it.do_read        = 1'b1;
    162             1                    ***0***           it.inject_rx_frame= 1'b1;
    163             1                    ***0***           it.bad_parity     = 1'b1;
    164             1                    ***0***           it.bad_stop       = 1'b0;
    165             1                    ***0***           it.w_data         = $urandom_range(0, 255);
    166             1                    ***0***           finish_item(it);
    167                                                  end
    168                                                endtask
    169                                              endclass


=================================================================================
=== File: sequence_item.sv
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                        10         0        10     0.00%

================================Branch Details================================

Branch Coverage for file sequence_item.sv --

------------------------------------IF Branch------------------------------------
    2                                    ***0***     Count coming in to IF
    2               1                    ***0***       `uvm_object_utils(UART_sequence_item)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2                                    ***0***     Count coming in to IF
    2               2                    ***0***       `uvm_object_utils(UART_sequence_item)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2                                    ***0***     Count coming in to IF
    2               3                    ***0***       `uvm_object_utils(UART_sequence_item)
    2               4                    ***0***       `uvm_object_utils(UART_sequence_item)
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2                                    ***0***     Count coming in to IF
    2               5                    ***0***       `uvm_object_utils(UART_sequence_item)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2                                    ***0***     Count coming in to IF
    2               6                    ***0***       `uvm_object_utils(UART_sequence_item)
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%


Condition Coverage:
    Enabled Coverage              Bins   Covered    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Conditions                       2         0         2     0.00%

================================Condition Details================================

Condition Coverage for file sequence_item.sv --

----------------Focused Condition View-------------------
Line       2 Item    1  (name != 0)
Condition totals: 0 of 1 input term covered = 0.00%

   Input Term   Covered  Reason for no coverage   Hint
  -----------  --------  -----------------------  --------------
  (name != 0)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  (name != 0)_0         -                             
  Row   2:    ***0***  (name != 0)_1         -                             

----------------Focused Condition View-------------------
Line       2 Item    2  (tmp_data__ != null)
Condition totals: 0 of 1 input term covered = 0.00%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (tmp_data__ != null)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:    ***0***  (tmp_data__ != null)_0  -                             
  Row   2:    ***0***  (tmp_data__ != null)_1  -                             


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      17         8         9    47.05%

================================Statement Details================================

Statement Coverage for file sequence_item.sv --

    1                                                class UART_sequence_item extends uvm_sequence_item;
    2               1                    ***0***       `uvm_object_utils(UART_sequence_item)
    2               2                    ***0***     
    2               3                    ***0***     
    2               4                    ***0***     
    2               5                    ***0***     
    2               6                        463     
    2               7                    ***0***     
    2               8                    ***0***     
    2               9                    ***0***     
    2              10                    ***0***     
    3                                                
    4                                                  // Transaction kind (used by monitor/scoreboard/coverage)
    5                                                  typedef enum int unsigned { TR_RESET = 0, TR_WRITE = 1, TR_READ = 2 } tr_kind_t;
    6               1                       1785       tr_kind_t kind = TR_WRITE;
    7                                                
    8                                                  // Stimulus
    9                                                  rand logic [7:0] w_data;
    10                                                 rand logic       Reset;
    11                                               
    12                                                 // Driver control knobs
    13              1                       1785       bit          do_write = 1'b1;
    14              1                       1785       bit          do_read  = 1'b1;
    15              1                       1785       int unsigned read_delay_cycles = 0;
    16                                               
    17                                                 // External RX injection knobs (run with -gLOOPBACK=0 +EXT_RX)
    18                                                 bit inject_rx_frame = 1'b0;
    19                                                 bit bad_parity      = 1'b0;
    20                                                 bit bad_stop        = 1'b0;
    21                                               
    22                                                 // Baud divider override
    23                                                 bit        set_divsr = 1'b0;
    24              1                       1785       logic [9:0] divsr    = 10'd54;
    25                                               
    26                                                 // Optional raw handshake flags
    27                                                 logic rd_uart, wr_uart;
    28                                               
    29                                                 // Observed from monitor
    30                                                 logic [7:0] r_data;
    31                                                 logic       tx_done, rx_done;
    32                                                 logic       tx_full, rx_empty;
    33                                                 logic       incorrect_send;
    34                                               
    35                                                 // Scoreboard control (monitor will set this on READ if it has expected)
    36              1                       1785       bit check_enable = 1'b1;
    37                                               
    38                                                 function new(string name = "UART_sequence_item");
    39              1                       1785         super.new(name);
    40                                                 endfunction
    41                                               
    42                                               endclass


=================================================================================
=== File: sequencer.sv
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                         8         4         4    50.00%

================================Branch Details================================

Branch Coverage for file sequencer.sv --

------------------------------------IF Branch------------------------------------
    7                                          1     Count coming in to IF
    7               1                    ***0***             `uvm_info(get_type_name() ," in constructor of sequencer ",UVM_HIGH)
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    12                                         1     Count coming in to IF
    12              1                          1             `uvm_info(get_type_name() ," in build_phase of sequencer ",UVM_LOW)
                                         ***0***     All False Count
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    17                                         1     Count coming in to IF
    17              1                          1             `uvm_info(get_type_name() ," in connect_phase of sequencer ",UVM_LOW)
                                         ***0***     All False Count
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    22                                         1     Count coming in to IF
    22              1                          1             `uvm_info(get_type_name() ," in run_phase of sequencer ",UVM_LOW)
                                         ***0***     All False Count
Branch totals: 1 hit of 2 branches = 50.00%


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      11         8         3    72.72%

================================Statement Details================================

Statement Coverage for file sequencer.sv --

    1                                                class sequencer extends uvm_sequencer #(UART_sequence_item);
    2                                                
    3               1                    ***0***         `uvm_component_utils(sequencer)
    3               2                    ***0***     
    3               3                          8     
    4                                                
    5                                                    function new(string name = "sequencer",uvm_component parent);
    6               1                          1             super.new(name , parent);
    7               1                    ***0***             `uvm_info(get_type_name() ," in constructor of sequencer ",UVM_HIGH)
    8                                                    endfunction 
    9                                                
    10                                                   function void build_phase (uvm_phase phase);
    11              1                          1             super.build_phase(phase);
    12              1                          1             `uvm_info(get_type_name() ," in build_phase of sequencer ",UVM_LOW)
    13                                                   endfunction: build_phase
    14                                               
    15                                                   function void connect_phase (uvm_phase phase);
    16              1                          1             super.connect_phase(phase);
    17              1                          1             `uvm_info(get_type_name() ," in connect_phase of sequencer ",UVM_LOW)
    18                                                   endfunction: connect_phase
    19                                               
    20                                                   task run_phase(uvm_phase phase);
    21              1                          1             super.run_phase(phase);
    22              1                          1             `uvm_info(get_type_name() ," in run_phase of sequencer ",UVM_LOW)
    23                                                   endtask: run_phase
    24                                               	
    25                                               endclass:sequencer


=================================================================================
=== File: test.sv
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                         2         1         1    50.00%

================================Branch Details================================

Branch Coverage for file test.sv --

------------------------------------IF Branch------------------------------------
    76                                         1     Count coming in to IF
    76              1                    ***0***         if ($test$plusargs("EXT_RX")) begin
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.00%


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      39        33         6    84.61%

================================Statement Details================================

Statement Coverage for file test.sv --

    1                                                class test extends uvm_test;
    2               1                    ***0***       `uvm_component_utils(test)
    2               2                    ***0***     
    2               3                          2     
    3                                                
    4                                                  env UART_env;
    5                                                
    6                                                  function new(string name = "test", uvm_component parent);
    7               1                          1         super.new(name, parent);
    8                                                  endfunction
    9                                                
    10                                                 function void build_phase(uvm_phase phase);
    11              1                          1         super.build_phase(phase);
    12              1                          1         UART_env = env::type_id::create("UART_env", this);
    13                                                 endfunction
    14                                               
    15                                                 function void end_of_elaboration_phase(uvm_phase phase);
    16              1                          1         super.end_of_elaboration_phase(phase);
    17              1                          1         this.print();
    18              1                          1         factory.print();
    19                                                 endfunction
    20                                               
    21                                                 task run_phase(uvm_phase phase);
    22                                                   // ----- handles -----
    23                                                   reset_sequence         rst;
    24                                                   all_zero_sequence      zeros;
    25                                                   all_one_sequence       ones;
    26                                                   burst_no_read_sequence burst;
    27                                                   drain_read_sequence    drain;
    28                                                   run_sequence           rand_seq;
    29                                                   rx_bad_parity_sequence badpar;
    30                                               
    31                                                   // ----- locals (DECLARATIONS MUST BE BEFORE STATEMENTS) -----
    32                                                   int unsigned TOTAL;
    33                                                   int unsigned CHUNK;
    34                                                   int unsigned base;
    35                                                   int unsigned i;
    36                                               
    37              1                          1         phase.raise_objection(this);
    38                                               
    39              1                          1         TOTAL = 128;
    40              1                          1         CHUNK = 32;
    41                                               
    42                                                   // 1) Reset
    43              1                          1         rst = reset_sequence::type_id::create("rst");
    44              1                          1         rst.start(UART_env.UART_agent.UART_sequencer);
    45                                               
    46                                                   // 2) Directed patterns
    47              1                          1         zeros = all_zero_sequence::type_id::create("zeros");
    48              1                          1         zeros.start(UART_env.UART_agent.UART_sequencer);
    49                                               
    50              1                          1         ones = all_one_sequence::type_id::create("ones");
    51              1                          1         ones.start(UART_env.UART_agent.UART_sequencer);
    52                                               
    53                                                   // 3) FIFO stress (SAFE chunked): 32 write(no read) -> 32 read, repeat
    54              1                          1         for (base = 0; base < TOTAL; base += CHUNK) begin
    54              2                          4     
    55              1                          4           burst = burst_no_read_sequence::type_id::create($sformatf("burst_%0d", base));
    56              1                          4           burst.n_bytes    = CHUNK;
    57              1                          4           burst.use_random = 1'b1;
    58              1                          4           burst.slow_baud  = 1'b1;
    59              1                          4           burst.slow_divsr = 10'd500;
    60              1                          4           burst.start(UART_env.UART_agent.UART_sequencer);
    61                                               
    62              1                          4           drain = drain_read_sequence::type_id::create($sformatf("drain_%0d", base));
    63              1                          4           drain.n_reads = CHUNK;
    64              1                          4           drain.read_delay_cycles = 0;
    65              1                          4           drain.start(UART_env.UART_agent.UART_sequencer);
    66                                                   end
    67                                               
    68                                                   // 4) Random traffic
    69              1                          1         for (i = 0; i < 200; i++) begin
    69              2                        200     
    70              1                        200           rand_seq = run_sequence::type_id::create($sformatf("rand_seq_%0d", i));
    71              1                        200           rand_seq.start(UART_env.UART_agent.UART_sequencer);
    72                                                   end
    73                                               
    74                                                   // 5) Optional negative test: external RX bad parity injection
    75                                                   // Run with: vsim -coverage -gLOOPBACK=0 +EXT_RX work.UART_TOP
    76                                                   if ($test$plusargs("EXT_RX")) begin
    77              1                    ***0***           badpar = rx_bad_parity_sequence::type_id::create("badpar");
    78              1                    ***0***           badpar.n_frames = 10;
    79              1                    ***0***           badpar.divsr    = 10'd54;
    80              1                    ***0***           badpar.start(UART_env.UART_agent.UART_sequencer);
    81                                                   end
    82                                               
    83              1                          1         phase.drop_objection(this);
    84                                                 endtask
    85                                               
    86                                               endclass


COVERGROUP COVERAGE:
----------------------------------------------------------------------------------------------------------
Covergroup                                             Metric       Goal       Bins    Status               
                                                                                                         
----------------------------------------------------------------------------------------------------------
 TYPE /UART_pkg/coverage_collector/UART_cg             67.18%        100          -    Uncovered            
    covered/total bins:                                    17         27          -                      
    missing/total bins:                                    10         27          -                      
    % Hit:                                             62.96%        100          -                      
    Coverpoint KIND                                   100.00%        100          -    Covered              
        covered/total bins:                                 3          3          -                      
        missing/total bins:                                 0          3          -                      
        % Hit:                                        100.00%        100          -                      
        bin rst                                             1          1          -    Covered              
        bin wr                                            330          1          -    Covered              
        bin rd                                            330          1          -    Covered              
    Coverpoint RESET                                  100.00%        100          -    Covered              
        covered/total bins:                                 2          2          -                      
        missing/total bins:                                 0          2          -                      
        % Hit:                                        100.00%        100          -                      
        bin asserted                                        1          1          -    Covered              
        bin deasserted                                    660          1          -    Covered              
    Coverpoint W_DATA                                  75.00%        100          -    Uncovered            
        covered/total bins:                                 3          4          -                      
        missing/total bins:                                 1          4          -                      
        % Hit:                                         75.00%        100          -                      
        bin all_zeros                                       4          1          -    Covered              
        bin all_ones                                        2          1          -    Covered              
        bin pat_aa                                          0          1          -    ZERO                 
        bin pat_55                                          2          1          -    Covered              
        default bin others                                322                     -    Occurred             
    Coverpoint R_DATA                                  75.00%        100          -    Uncovered            
        covered/total bins:                                 3          4          -                      
        missing/total bins:                                 1          4          -                      
        % Hit:                                         75.00%        100          -                      
        bin all_zeros                                       4          1          -    Covered              
        bin all_ones                                        2          1          -    Covered              
        bin pat_aa                                          0          1          -    ZERO                 
        bin pat_55                                          2          1          -    Covered              
        default bin others                                322                     -    Occurred             
    Coverpoint TX_FULL                                 50.00%        100          -    Uncovered            
        covered/total bins:                                 1          2          -                      
        missing/total bins:                                 1          2          -                      
        % Hit:                                         50.00%        100          -                      
        bin not_full                                      330          1          -    Covered              
        bin full                                            0          1          -    ZERO                 
    Coverpoint RX_EMPTY                                50.00%        100          -    Uncovered            
        covered/total bins:                                 1          2          -                      
        missing/total bins:                                 1          2          -                      
        % Hit:                                         50.00%        100          -                      
        bin not_empty                                     330          1          -    Covered              
        bin empty                                           0          1          -    ZERO                 
    Coverpoint INCORRECT_SEND                          50.00%        100          -    Uncovered            
        covered/total bins:                                 1          2          -                      
        missing/total bins:                                 1          2          -                      
        % Hit:                                         50.00%        100          -                      
        bin ok                                            330          1          -    Covered              
        bin err                                             0          1          -    ZERO                 
    Cross X_WDATA_FULL                                 37.50%        100          -    Uncovered            
        covered/total bins:                                 3          8          -                      
        missing/total bins:                                 5          8          -                      
        % Hit:                                         37.50%        100          -                      
        Auto, Default and User Defined Bins:
            bin <pat_55,not_full>                           2          1          -    Covered              
            bin <all_ones,not_full>                         2          1          -    Covered              
            bin <all_zeros,not_full>                        4          1          -    Covered              
            bin <pat_aa,*>                                  0          1          2    ZERO                 
            bin <*,full>                                    0          1          4    ZERO                 
 Covergroup instance \/UART_pkg::coverage_collector::UART_cg  
                                                       67.18%        100          -    Uncovered            
    covered/total bins:                                    17         27          -                      
    missing/total bins:                                    10         27          -                      
    % Hit:                                             62.96%        100          -                      
    Coverpoint KIND                                   100.00%        100          -    Covered              
        covered/total bins:                                 3          3          -                      
        missing/total bins:                                 0          3          -                      
        % Hit:                                        100.00%        100          -                      
        bin rst                                             1          1          -    Covered              
        bin wr                                            330          1          -    Covered              
        bin rd                                            330          1          -    Covered              
    Coverpoint RESET                                  100.00%        100          -    Covered              
        covered/total bins:                                 2          2          -                      
        missing/total bins:                                 0          2          -                      
        % Hit:                                        100.00%        100          -                      
        bin asserted                                        1          1          -    Covered              
        bin deasserted                                    660          1          -    Covered              
    Coverpoint W_DATA                                  75.00%        100          -    Uncovered            
        covered/total bins:                                 3          4          -                      
        missing/total bins:                                 1          4          -                      
        % Hit:                                         75.00%        100          -                      
        bin all_zeros                                       4          1          -    Covered              
        bin all_ones                                        2          1          -    Covered              
        bin pat_aa                                          0          1          -    ZERO                 
        bin pat_55                                          2          1          -    Covered              
        default bin others                                322                     -    Occurred             
    Coverpoint R_DATA                                  75.00%        100          -    Uncovered            
        covered/total bins:                                 3          4          -                      
        missing/total bins:                                 1          4          -                      
        % Hit:                                         75.00%        100          -                      
        bin all_zeros                                       4          1          -    Covered              
        bin all_ones                                        2          1          -    Covered              
        bin pat_aa                                          0          1          -    ZERO                 
        bin pat_55                                          2          1          -    Covered              
        default bin others                                322                     -    Occurred             
    Coverpoint TX_FULL                                 50.00%        100          -    Uncovered            
        covered/total bins:                                 1          2          -                      
        missing/total bins:                                 1          2          -                      
        % Hit:                                         50.00%        100          -                      
        bin not_full                                      330          1          -    Covered              
        bin full                                            0          1          -    ZERO                 
    Coverpoint RX_EMPTY                                50.00%        100          -    Uncovered            
        covered/total bins:                                 1          2          -                      
        missing/total bins:                                 1          2          -                      
        % Hit:                                         50.00%        100          -                      
        bin not_empty                                     330          1          -    Covered              
        bin empty                                           0          1          -    ZERO                 
    Coverpoint INCORRECT_SEND                          50.00%        100          -    Uncovered            
        covered/total bins:                                 1          2          -                      
        missing/total bins:                                 1          2          -                      
        % Hit:                                         50.00%        100          -                      
        bin ok                                            330          1          -    Covered              
        bin err                                             0          1          -    ZERO                 
    Cross X_WDATA_FULL                                 37.50%        100          -    Uncovered            
        covered/total bins:                                 3          8          -                      
        missing/total bins:                                 5          8          -                      
        % Hit:                                         37.50%        100          -                      
        Auto, Default and User Defined Bins:
            bin <pat_55,not_full>                           2          1          -    Covered              
            bin <all_ones,not_full>                         2          1          -    Covered              
            bin <all_zeros,not_full>                        4          1          -    Covered              
            bin <pat_aa,*>                                  0          1          2    ZERO                 
            bin <*,full>                                    0          1          4    ZERO                 

TOTAL COVERGROUP COVERAGE: 67.18%  COVERGROUP TYPES: 1

ASSERTION RESULTS:
--------------------------------------------------------------------
Name                 File(Line)                   Failure      Pass 
                                                  Count        Count
--------------------------------------------------------------------
/UART_TOP/intf/a_no_rd_when_empty
                     UART_interface.sv(37)              0          1
/UART_TOP/intf/a_no_wr_when_full
                     UART_interface.sv(43)              0          1
/UART_TOP/intf/a_tx_done_pulse
                     UART_interface.sv(49)              0          1
/UART_TOP/intf/a_rx_done_pulse
                     UART_interface.sv(55)              0          1
/UART_pkg/run_sequence/body/immed__32
                     sequence.sv(32)                    0          1

Total Coverage By File (code coverage only, filtered view): 46.84%

